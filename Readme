EXPENSE TRACKER

A RESTful expense tracking application built with Flask, PostgreSQL, SQLAlchemy, and Celery.
The application provides authenticated APIs for managing budgets, transactions, and categories, with support for recurring financial operations.

The project was designed with modularity and backend best practices in mind and serves as a practical demonstration of building, structuring, and running a moderately complex, production-style Python web application.

A lightweight frontend (AI-generated) is included as a simple interface for interacting with the API.
Interactive API documentation is available via Swagger UI.

Core Features:
-Authentication
-JWT-based access tokens
-Protected routes
-Cookie-based authorization support

Transactions:
-Full CRUD operations
-Input validation
-Support for income and expense categories
-Optional recurring transactions (monthly, demo implementation)

Budgets:
-Create and edit monthly budgets
-Assign transactions to budgets
-View spending and income distribution for the active budget

Background Processing:
-Periodic and batch jobs handled with Celery (Demo)
-Redis used as a message broker

Tech Stack:
-Python 3.12
-Flask
-SQLAlchemy
-PostgreSQL
-Celery
-Redis

## Quickstart (Local)
### Prerequisites
- Python 3.12
- PostgreSQL

### Database setup
Before running the app:
1. Install PostgreSQL
2. Create a database (e.g expense_tracker)
- createdb expense_tracker
- psql -U postgres -d expense_tracker < sampledb.sql
3. Configure environment variables (see .env.example)

### Python and project prep
1.Create virtual environment
python -m venv .venv
2. Activate virtual environment (Windows)
source .venv/Scripts/activate
3. Install dependencies
pip install -r requirements.txt
4. Run the application
python main.py

API Documentation:
Swagger UI is available at:
{BASE_URL}/swagger

What I'd work on next:
To improve scalability, I would step away from using raw data from DB and convert everything into objects, making it easier to manage internal states.
I would add a role based authentication, allowing for more modular design. This would also open doors for bigger customization options for users.
To minimize risk of performance issues, I'd employ pagination and asynchronous database calls with e.g celery.
